<?php
namespace App\Http\Controllers;

use Illuminate\Support\Facades\Schema;
use App\Models\Patient;
use App\Models\Doctor;
use App\Models\Prescription;
use Illuminate\Support\Str;
use Illuminate\Http\Request;

use Illuminate\Http\JsonResponse;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;


class PatientController extends Controller
{
    public function index()
    {

        $patients = Patient::with('doctor')      // keep doctor name
        ->withCount('prescriptions')                    // adds prescriptions_count
        ->orderBy('name')
        ->paginate(10);

        // $patients = Patient::with('doctor')->get();
        return view('admin.patients.index', compact('patients'));
    }

    public function create()
    {
        $doctors = Doctor::all();
        return view('admin.patients.create', compact('doctors'));
    }

    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'doctor_id' => 'nullable|exists:doctors,id',
            'age' => 'nullable|integer|min:0',
            'sex' => 'nullable|in:male,female,others',
            'dob' => 'nullable|date',
            'address' => 'nullable|string',
            'images.*' => 'nullable|image|mimes:jpg,jpeg,png,gif',
            'documents.*' => 'nullable|file|mimes:pdf,jpg,jpeg,png,gif,doc,docx',
            'status' => 'required|in:active,inactive',
            'phone' => 'nullable|string|max:20',
            'email' => 'nullable|email|max:255',
            'notes' => 'nullable|string',
        ]);

       $images = [];
        if ($request->hasFile('images')) {
            foreach ($request->file('images') as $image) {
                $images[] = $image->store('patients/images', 'public');
            }
        }

        $documents = [];
        if ($request->hasFile('documents')) {
            foreach ($request->file('documents') as $doc) {
                $documents[] = $doc->store('patients/documents', 'public');
            }
        }

        $data = $request->except(['images', 'documents']);
        $data['images'] = $images;
        $data['documents'] = $documents;

        Patient::create($data);

        return redirect()->route('patients.index')->with('success', 'Patient added successfully.');
    }

    public function edit(Patient $patient)
    {
        $doctors = Doctor::all();
        return view('admin.patients.edit', compact('patient', 'doctors'));
    }

    public function update(Request $request, Patient $patient)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'doctor_id' => 'nullable|exists:doctors,id',
            'age' => 'nullable|integer|min:0',
            'sex' => 'nullable|in:male,female,others',
            'dob' => 'nullable|date',
            'address' => 'nullable|string',
            'images.*' => 'nullable|image|mimes:jpg,jpeg,png,gif',
            'documents.*' => 'nullable|file|mimes:pdf,jpg,jpeg,png,gif,doc,docx',
            'status' => 'required|in:active,inactive',
            'phone' => 'nullable|string|max:20',
            'email' => 'nullable|email|max:255',
            'notes' => 'nullable|string',
        ]);

        $data = $request->except(['images', 'documents']);

        $data['images'] = $patient->images;
        if ($request->hasFile('images')) {
            $images = [];
            foreach ($request->file('images') as $image) {
                $images[] = $image->store('patients/images', 'public');
            }
            $data['images'] = $images;
        }

        $data['documents'] = $patient->documents;
        if ($request->hasFile('documents')) {
            $documents = [];
            foreach ($request->file('documents') as $doc) {
                $documents[] = $doc->store('patients/documents', 'public');
            }
            $data['documents'] = $documents;
        }

        $patient->update($data);

        return redirect()->route('patients.index')->with('success', 'Patient updated successfully.');
    }

    public function destroy(Patient $patient)
    {
        $patient->delete();
        return redirect()->route('patients.index')->with('success', 'Patient deleted successfully.');
    }

     public function search(Request $r)
    {
        $q    = trim($r->input('term', $r->input('q', '')));
        $page = max(1, (int) $r->input('page', 1));
        $per  = 20;

        $builder = Patient::query();
        if ($q !== '') {
            $builder->where(function ($w) use ($q) {
                $w->where('name', 'like', "%{$q}%")
                  ->orWhere('phone', 'like', "%{$q}%")
                  ->orWhere('email', 'like', "%{$q}%");
            });
        }

        $total   = $builder->count();
        $results = $builder->orderBy('name')
            ->skip(($page - 1) * $per)
            ->take($per)
            ->get(['id', 'name', 'phone', 'email', 'notes']);

        // For Select2, `text` is what shows after selection
        return response()->json([
            'results' => $results->map(fn ($p) => [
                'id'    => $p->id,
                'text'  => $p->name . ($p->phone ? " ({$p->phone})" : ''),
                'name'  => $p->name,
                'phone' => $p->phone,
                'email' => $p->email,
                'notes' => $p->notes,
            ]),
            'pagination' => [ 'more' => ($page * $per) < $total ],
        ]);
    }

// public function history(Patient $patient, Request $r)
// {
//     $limit = min(50, max(1, (int) $r->input('limit', 10)));

//     // Pull recent prescriptions. If you have a 'doctor' relation, keep with('doctor').
//     $items = Prescription::where('patient_id', $patient->id)
//         ->with('doctor')                // remove if you don't have it
//         ->latest()
//         ->take($limit)
//         ->get();

//     return response()->json([
//         'patient' => [
//             'id'   => $patient->id,
//             'name' => $patient->name,
//         ],
//         'count' => $items->count(),
//         'items' => $items->map(fn ($p) => [
//             'id'            => $p->id,
//             'date'          => optional($p->created_at)->format('Y-m-d'),
//             'doctor_name'   => optional($p->doctor)->name, // null if no relation
//             'problem'       => (string) str($p->problem_description ?? '')->limit(120),
//             // Optional: include a URL if you have a show route like /prescriptions/{id}
//             'url'           => url('/prescriptions/'.$p->id),
//         ]),
//     ]);
// }

// public function history(Patient $patient, Request $request)
// {
//     $limit = min(50, max(1, (int) $request->input('limit', 10)));

//     // Pull recent prescriptions; select only safe fields to avoid unknown columns.
//     $items = Prescription::where('patient_id', $patient->id)
//         ->orderByDesc('id')
//         ->limit($limit)
//         ->get(['id', 'created_at', 'doctor_id', 'problem_description']); // adjust column names if needed

//     // If you have a doctors table but no relation, resolve names cheaply (optional)
//     $doctorNames = [];
//     if (Schema::hasTable('doctors')) {
//         $doctorIds = $items->pluck('doctor_id')->filter()->unique()->values();
//         if ($doctorIds->isNotEmpty()) {
//             $doctorNames = \DB::table('doctors')
//                 ->whereIn('id', $doctorIds)
//                 ->pluck('name', 'id')
//                 ->toArray();
//         }
//     }

//     return response()->json([
//         'patient' => ['id' => $patient->id, 'name' => $patient->name],
//         'count'   => $items->count(),
//         'items'   => $items->map(function ($p) use ($doctorNames) {
//             $date  = optional($p->created_at)->format('Y-m-d');
//             $doc   = $doctorNames[$p->doctor_id] ?? null;        // null-safe
//             $prob  = $p->problem_description ?? null;            // null-safe; rename if your column differs
//             return [
//                 'id'          => $p->id,
//                 'date'        => $date,
//                 'doctor_name' => $doc,
//                 'problem'     => $prob ? \Illuminate\Support\Str::limit($prob, 120) : null,
//                 'url'         => route('prescriptions.show', $p->id), // ensure this route exists or swap to url('/prescriptions/'.$p->id)
//             ];
//         }),
//     ]);
// }

public function history(Patient $patient, Request $request)
{
    $limit = min(50, max(1, (int) $request->input('limit', 10)));

    $items = Prescription::where('patient_id', $patient->id)
        ->orderByDesc('id')
        ->limit($limit)
        ->get(['id', 'created_at', 'doctor_id', 'problem_description']); // rename fields if needed

    // Optional: resolve doctor names (only if doctors table exists)
    $doctorNames = [];
    if (Schema::hasTable('doctors')) {
        $doctorIds = $items->pluck('doctor_id')->filter()->unique();
        if ($doctorIds->isNotEmpty()) {
            $doctorNames = Doctor::whereIn('id', $doctorIds)->pluck('name', 'id')->toArray();
        }
    }

    return response()->json([
        'patient' => ['id' => $patient->id, 'name' => $patient->name],
        'count'   => $items->count(),
        'items'   => $items->map(function ($p) use ($doctorNames) {
            return [
                'id'          => $p->id,
                'date'        => optional($p->created_at)->format('Y-m-d'),
                'doctor_name' => $doctorNames[$p->doctor_id] ?? null,
                'problem'     => $p->problem_description ? Str::limit($p->problem_description, 120) : null,
                'url'         => url('/prescriptions/'.$p->id),
            ];
        }),
    ]);
}

// public function documents(Patient $patient): JsonResponse
//     {
//         // documents is a JSON array column: ["patients/documents/file1.pdf", ...]
//         $paths = collect($patient->documents ?? [])
//             ->filter(fn ($p) => filled($p))
//             ->values();

//         $items = $paths->map(function (string $path) {
//             // You likely stored on the 'public' disk. If it's a relative path, turn it into a URL.
//             // If it's already an absolute URL (CDN/S3), keep it.
//             $isAbsolute = Str::startsWith($path, ['http://', 'https://', '/storage/', 'storage/']);
//             $url = $isAbsolute ? $path : Storage::disk('public')->url($path);

//             // Guess mime from the extension (cheap & fast). You can also try Storage::mimeType if local.
//             $ext = strtolower(pathinfo(parse_url($path, PHP_URL_PATH), PATHINFO_EXTENSION));
//             $mimeMap = [
//                 'png'  => 'image/png',
//                 'jpg'  => 'image/jpeg',
//                 'jpeg' => 'image/jpeg',
//                 'webp' => 'image/webp',
//                 'gif'  => 'image/gif',
//                 'svg'  => 'image/svg+xml',
//                 'pdf'  => 'application/pdf',
//             ];
//             $mime = $mimeMap[$ext] ?? 'application/octet-stream';

//             return [
//                 'id'          => md5($path),                         // stable-ish id
//                 'name'        => basename($path),
//                 'url'         => $url,                               // used to open/preview
//                 'thumb_url'   => in_array($ext, ['png','jpg','jpeg','webp','gif','svg']) ? $url : null,
//                 'mime'        => $mime,
//                 'uploaded_at' => null,                               // add if you track it
//             ];
//         });

//         return response()->json(['data' => $items]);
//     }

//  public function documents(Patient $patient): JsonResponse
//     {
//         // Example DB value: ["patients/documents/tRksh...FfAs.pdf"]
//         $paths = collect($patient->documents ?? [])
//             ->filter(fn ($p) => filled($p))
//             ->values();

//         $items = $paths->map(function (string $path) {
//             $isAbsolute = Str::startsWith($path, ['http://','https://','/storage/','storage/']);
//             $url = $isAbsolute ? $path : Storage::disk('public')->url($path);

//             $ext = strtolower(pathinfo(parse_url($path, PHP_URL_PATH), PATHINFO_EXTENSION));
//             $mime = match ($ext) {
//                 'png' => 'image/png',
//                 'jpg', 'jpeg' => 'image/jpeg',
//                 'webp' => 'image/webp',
//                 'gif' => 'image/gif',
//                 'svg' => 'image/svg+xml',
//                 'pdf' => 'application/pdf',
//                 default => 'application/octet-stream',
//             };

//             return [
//                 'id'        => md5($path),
//                 'name'      => basename($path),
//                 'url'       => $url,
//                 'thumb_url' => in_array($ext, ['png','jpg','jpeg','webp','gif','svg']) ? $url : null,
//                 'mime'      => $mime,
//                 'uploaded_at' => null,
//             ];
//         })->values(); // ensure array-like

//         return response()->json(['data' => $items]);
//     }
public function documents(Patient $patient): JsonResponse
    {
        try {
            // Normalize documents to array (handles: array, JSON string, null)
            $raw = $patient->documents;
            if (is_string($raw)) {
                $decoded = json_decode($raw, true);
                $paths = is_array($decoded) ? $decoded : [];
            } elseif (is_array($raw)) {
                $paths = $raw;
            } else {
                $paths = [];
            }

            $paths = collect($paths)
                ->filter(fn($p) => is_string($p) && trim($p) !== '')
                ->values();

            $items = $paths->map(function (string $path) {
                // Build a URL for relative public paths
                $isAbsolute = Str::startsWith($path, ['http://','https://','/storage/','storage/']);
                // If you save to "public" disk (default), this builds /storage/...
                $url = $isAbsolute ? $path : Storage::disk('public')->url($path);

                // Guess mime by extension (fast & good enough)
                $ext = strtolower(pathinfo(parse_url($path, PHP_URL_PATH), PATHINFO_EXTENSION));
                $mime = match ($ext) {
                    'png' => 'image/png',
                    'jpg', 'jpeg' => 'image/jpeg',
                    'webp' => 'image/webp',
                    'gif' => 'image/gif',
                    'svg' => 'image/svg+xml',
                    'pdf' => 'application/pdf',
                    default => 'application/octet-stream',
                };

                return [
                    'id'        => md5($path),
                    'name'      => basename($path),
                    'url'       => $url,
                    'thumb_url' => in_array($ext, ['png','jpg','jpeg','webp','gif','svg']) ? $url : null,
                    'mime'      => $mime,
                    'uploaded_at' => null,
                ];
            })->values();

            return response()->json(['data' => $items], 200);
        } catch (\Throwable $e) {
            // Log the real error; return a readable message for the UI
            Log::error('patients.documents error', [
                'patient_id' => $patient->id ?? null,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            return response()->json([
                'data' => [],
                'error' => $e->getMessage(),
            ], 500);
        }
    }


}
